# Python 리스트 실습 문제 완전 해설

# ============================
# 첫번째 요소와 마지막 요소 접근
# ============================

nums = [10, 20, 30, 40, 50]
# 양수 인덱스:  0   1   2   3   4
# 음수 인덱스: -5  -4  -3  -2  -1

print('첫번째 요소:', nums[0])   # 출력: 첫번째 요소: 10 (양수 인덱스 0 사용)
print('마지막 요소:', nums[-1])  # 출력: 마지막 요소: 50 (음수 인덱스 -1 사용)
print()  # 빈 줄 출력

# ============================
# 가운데 세 개의 요소 추출
# ============================

nums = [100, 200, 300, 400, 500, 600, 700]
# 인덱스: 0    1    2    3    4    5    6
# 총 7개 요소 → 가운데 인덱스는 3 (7//2 = 3)

mid = len(nums) // 2  # mid = 7 // 2 = 3 (정수 나눗셈으로 가운데 인덱스 계산)
print('가운데 세 개의 요소:', nums[mid-1:mid+2])
# nums[3-1:3+2] → nums[2:5] → 인덱스 2,3,4의 요소들 → [300, 400, 500]
# 출력: 가운데 세 개의 요소: [300, 400, 500]
print()

# ============================
# 리스트의 모든 원소를 두 배로 만들기
# ============================

nums = [1, 2, 3, 4, 5]
# 반복문을 사용하여 각 요소에 접근하고 2를 곱함
for i in range(len(nums)):  # i는 0,1,2,3,4 순서로 변화 (리스트 길이만큼 반복)
    nums[i] *= 2    # nums[i] = nums[i] * 2와 동일한 복합 대입 연산자
    # 1회차: nums[0] = 1 * 2 = 2
    # 2회차: nums[1] = 2 * 2 = 4
    # 3회차: nums[2] = 3 * 2 = 6
    # 4회차: nums[3] = 4 * 2 = 8
    # 5회차: nums[4] = 5 * 2 = 10

print('nums:', nums)  # 출력: nums: [2, 4, 6, 8, 10]
print()

# ============================
# 리스트 뒤집기 (슬라이싱 활용)
# ============================

items = ['a', 'b', 'c', 'd', 'e']
# [::-1]은 전체 리스트를 역순으로 슬라이싱하는 패턴
# 시작:끝:스텝 → 전체:전체:-1 (뒤에서부터 앞으로 1칸씩)
print('리스트 뒤집기:', items[::-1])  # 출력: 리스트 뒤집기: ['e', 'd', 'c', 'b', 'a']
print()

# ============================
# 짝수 인덱스 요소만 출력 (0, 2, 4, ...)
# ============================

data = ['zero', 'one', 'two', 'three', 'four', 'five']
# 인덱스:  0      1     2      3       4       5
# [::2]는 처음부터 끝까지 2칸씩 건너뛰며 슬라이싱
# 인덱스 0('zero'), 2('two'), 4('four') 선택
print('짝수 인덱스 요소:', data[::2])  # 출력: 짝수 인덱스 요소: ['zero', 'two', 'four']
print()

# ============================
# 슬라이싱으로 리스트의 일부 요소를 다른 요소들로 교체
# ============================

movies = ['인셉션', '인터스텔라', '어벤져스', '라라랜드', '기생충']
# 인덱스:   0        1         2        3        4

# movies[2:4]는 인덱스 2,3의 요소들 ['어벤져스', '라라랜드']를 의미
# 슬라이싱 교체: 기존 2개 요소를 새로운 2개 요소로 교체 (길이 유지)
movies[2:4] = ['매트릭스', '타이타닉']
print('movies:', movies)  # 출력: movies: ['인셉션', '인터스텔라', '매트릭스', '타이타닉', '기생충']
print()

# ============================
# 특정 규칙에 따라 요소 추출 (시작:끝:스텝)
# ============================

subjects = ['국어', '수학', '영어', '물리', '화학',
            '생물', '역사', '지구과학', '윤리']
# 인덱스:  0      1      2      3      4
#         5      6      7         8

# subjects[3:9:2] → 인덱스 3부터 8까지(9 미포함) 2칸씩 건너뛰며 추출
# 선택되는 인덱스: 3('물리'), 5('생물'), 7('지구과학')
result = subjects[3:9:2]
print('특정 규칙 추출 결과:', result)  # 출력: 특정 규칙 추출 결과: ['물리', '생물', '지구과학']
print()

# ============================
# 리스트를 3구간으로 나누어 각각 역순으로 만든 후 출력
# ============================

data = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
# 인덱스: 0    1    2    3    4    5    6    7    8
# 총 9개 요소를 3개씩 나누어 각 구간을 역순으로 처리

# 첫 번째 구간: 인덱스 0~2 (3개 요소)
part1 = data[0:3][::-1]   # data[0:3] → ['A','B','C'] → 뒤집기 → ['C','B','A']
# 두 번째 구간: 인덱스 3~5 (3개 요소)
part2 = data[3:6][::-1]   # data[3:6] → ['D','E','F'] → 뒤집기 → ['F','E','D']
# 세 번째 구간: 인덱스 6~8 (3개 요소)
part3 = data[6:9][::-1]   # data[6:9] → ['G','H','I'] → 뒤집기 → ['I','H','G']

print('3구간 역순 결과:', part1, part2, part3, sep=' ')
# 출력: 3구간 역순 결과: ['C', 'B', 'A'] ['F', 'E', 'D'] ['I', 'H', 'G']
print()

# ============================
# 추가 실습: 다양한 슬라이싱 패턴
# ============================

numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 홀수 인덱스 요소만 추출 (1, 3, 5, 7, 9)
print('홀수 인덱스 요소:', numbers[1::2])  # 출력: 홀수 인덱스 요소: [1, 3, 5, 7, 9]

# 뒤에서 3개 요소만 추출
print('뒤에서 3개:', numbers[-3:])  # 출력: 뒤에서 3개: [7, 8, 9]

# 처음 5개 중에서 2칸씩 건너뛰며 추출
print('처음 5개 중 2칸씩:', numbers[:5:2])  # 출력: 처음 5개 중 2칸씩: [0, 2, 4]

# 중간 부분 역순으로 추출 (인덱스 2~7을 역순)
print('중간부분 역순:', numbers[2:8][::-1])  # 출력: 중간부분 역순: [7, 6, 5, 4, 3, 2]
print()

# ============================
# 종합 정리
# ============================

"""
주요 리스트 조작 기법 완전 정리:

1. 인덱싱 (단일 요소 접근):
   - 양수 인덱스: 앞에서부터 0, 1, 2, ... (첫 요소는 0)
   - 음수 인덱스: 뒤에서부터 -1, -2, -3, ... (마지막 요소는 -1)
   - 범위 초과 시 IndexError 발생

2. 슬라이싱 (여러 요소 접근):
   - 기본 문법: [시작:끝:스텝]
   - 끝 인덱스는 포함되지 않음 (미만의 개념)
   - 범위 초과 시 에러 없이 빈 리스트 또는 일부만 반환

3. 슬라이싱 주요 패턴:
   - [::-1]: 전체 뒤집기 (역순)
   - [::2]: 짝수 인덱스 (0, 2, 4, ...)
   - [1::2]: 홀수 인덱스 (1, 3, 5, ...)
   - [-n:]: 뒤에서 n개
   - [:n]: 앞에서 n개
   - [start:end]: 특정 범위

4. 요소 수정 방법:
   - 개별 수정: list[index] = new_value
   - 범위 수정: list[start:end] = new_list
   - 길이 변경 가능: 다른 길이의 리스트로 교체 가능

5. 실용적 응용:
   - 가운데 요소: list[len(list)//2]
   - 리스트 분할: 슬라이싱으로 구간별 처리
   - 조건부 추출: 스텝을 활용한 패턴 추출
   - 복합 연산: 슬라이싱 + 뒤집기 조합

6. 성능 고려사항:
   - 슬라이싱은 새로운 리스트 객체를 생성 (메모리 사용)
   - 큰 리스트에서는 메모리 효율성 고려 필요
   - 반복문보다 슬라이싱이 일반적으로 더 빠름

"""
