"""
OpenCV 기초 - 04. 종합 실습

이 파일에서 배울 내용:
1. 여러 색상 영역으로 이루어진 이미지 만들기
2. 채널 조작으로 색상 바꾸기
3. ROI(관심 영역)를 이용한 이미지 복사
4. 그라데이션 이미지 만들기
"""

import cv2
import numpy as np

# ============================================================
# 실습 1: 빨강, 초록, 파랑 3색 정사각형 만들기
# ============================================================
"""
목표: 가로로 긴 이미지에 3개의 정사각형을 나란히 그리고
각각 빨강, 초록, 파랑 색상으로 채우기
"""

# 300x900 크기의 검은색 이미지 생성
img = np.zeros((300, 900, 3), dtype=np.uint8)

# 슬라이싱으로 각 영역에 색상 지정
# ⚠️ OpenCV는 BGR 순서를 사용!
img[:, 0:300] = [0, 0, 255]     # 왼쪽 정사각형: 빨간색 (Red)
img[:, 300:600] = [0, 255, 0]   # 가운데 정사각형: 초록색 (Green)
img[:, 600:900] = [255, 0, 0]   # 오른쪽 정사각형: 파란색 (Blue)

cv2.imshow('RGB Squares (빨강, 초록, 파랑)', img)
print("실습 1: 3색 정사각형 생성 완료!")
cv2.waitKey(0)
cv2.destroyAllWindows()

# ============================================================
# 실습 2: 채널 조작으로 색상 바꾸기
# ============================================================
"""
목표: 노란색 이미지를 만들고, 채널을 조작해서 색상 변경하기

채널이란?
- BGR 이미지는 Blue, Green, Red 3개의 채널로 구성
- 각 채널의 값을 바꾸면 색상이 변해요
"""

# 노란색 이미지 생성
# 노란색 = 초록(G) + 빨강(R) = BGR(0, 255, 255)
img = np.zeros((200, 200, 3), dtype=np.uint8)
img[:] = [0, 255, 255]  # 노란색으로 채우기

# 각 채널을 분리 (참조 형태로)
b = img[:, :, 0]  # Blue 채널
g = img[:, :, 1]  # Green 채널
r = img[:, :, 2]  # Red 채널

# Blue와 Green 채널을 0으로 만들기
b[:] = 0  # Blue 제거
g[:] = 0  # Green 제거
# 결과: Red만 남아서 빨간색이 됨!

# 원본과 수정된 이미지 비교
cv2.imshow('Original (원본 - 노란색)', img)
cv2.imshow('Modified (수정됨 - 빨간색)', cv2.merge([b, g, r]))
print("\n실습 2: 채널 조작 완료!")
print("노란색에서 Blue와 Green을 제거하면 빨간색이 됩니다.")
cv2.waitKey(0)
cv2.destroyAllWindows()



# ============================================================
# 실습 3: ROI를 이용한 이미지 합성
# ============================================================
"""
ROI(Region of Interest)란?
- 관심 영역, 즉 이미지의 특정 부분
- 슬라이싱을 사용해서 특정 영역만 선택하고 수정할 수 있어요

목표: 작은 빨간 사각형을 큰 파란 사각형의 정중앙에 배치하기
"""

# 큰 파란색 이미지 만들기 (400x400)
img1 = np.zeros((400, 400, 3), dtype=np.uint8)
img1[:] = [255, 0, 0]  # 파란색으로 채우기

# 작은 빨간색 이미지 만들기 (200x200)
img2 = np.zeros((200, 200, 3), dtype=np.uint8)
img2[:] = [0, 0, 255]  # 빨간색으로 채우기

# 두 이미지의 크기 구하기
h1, w1 = img1.shape[:2]  # img1의 높이, 너비
h2, w2 = img2.shape[:2]  # img2의 높이, 너비

# img2를 img1의 정중앙에 배치하기 위한 시작 좌표 계산
y = (h1 - h2) // 2  # 세로 중앙 위치: (400 - 200) // 2 = 100
x = (w1 - w2) // 2  # 가로 중앙 위치: (400 - 200) // 2 = 100

# ROI를 사용해서 img2를 img1의 중앙에 복사
# img1[100:300, 100:300] 영역에 img2 전체를 복사
img1[y:y+h2, x:x+w2] = img2

cv2.imshow('ROI Copy (중앙에 배치)', img1)
print("\n실습 3: ROI 복사 완료!")
print(f"200x200 빨간 사각형을 400x400 파란 배경의 중앙({x}, {y})에 배치했습니다.")
cv2.waitKey(0)
cv2.destroyAllWindows()

# ============================================================
# 실습 4: 그라데이션 이미지 만들기
# ============================================================
"""
그라데이션이란?
- 색상이나 밝기가 점진적으로 변하는 효과
- 배경 이미지, 디자인 요소 등에 많이 사용돼요

목표:
1. 왼쪽→오른쪽으로 어두워지는 수평 그라데이션
2. 위→아래로 어두워지는 수직 그라데이션
3. 두 그라데이션을 합성한 효과
"""

# 1. 수평 그라데이션 (왼쪽: 검정 → 오른쪽: 흰색)
# np.linspace(0, 255, 300): 0부터 255까지 300개의 값을 균등하게 생성
# np.tile(): 1차원 배열을 300번 반복해서 300x300 이미지로 만들기
h_grad = np.tile(np.linspace(0, 255, 300), (300, 1)).astype(np.uint8)

# 2. 수직 그라데이션 (위: 검정 → 아래: 흰색)
# .T는 전치(Transpose): 행과 열을 바꿔서 세로 그라데이션으로 만들기
v_grad = np.tile(np.linspace(0, 255, 300), (300, 1)).T.astype(np.uint8)

# 3. 두 그라데이션 합성 (평균 내기)
# 두 이미지의 밝기 값을 더한 후 2로 나누어 평균값 사용
# float32로 변환한 이유: 계산 중 오버플로우 방지
combined = ((h_grad.astype(np.float32)
            + v_grad.astype(np.float32)) / 2).astype(np.uint8)

# 3개의 그라데이션 이미지 보여주기
cv2.imshow('Horizontal Gradient (수평)', h_grad)
cv2.imshow('Vertical Gradient (수직)', v_grad)
cv2.imshow('Combined Gradient (합성)', combined)
print("\n실습 4: 그라데이션 이미지 생성 완료!")
print("수평, 수직, 합성 그라데이션을 확인하세요.")
cv2.waitKey(0)
cv2.destroyAllWindows()

print("\n\n🎉 모든 실습 완료! 🎉")



