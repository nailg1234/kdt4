# ============================================
# 문제 1: 구명보트 (Greedy Algorithm)
# ============================================
# 문제 설명:
# 무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다.
# 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.
#
# 예제:
# - 사람들의 몸무게: [70kg, 50kg, 80kg, 50kg]
# - 구명보트의 무게 제한: 100kg
# - 2번째 사람(50kg)과 4번째 사람(50kg)은 같이 탈 수 있음 (100kg)
# - 1번째 사람(70kg)과 3번째 사람(80kg)은 같이 탈 수 없음 (150kg > 100kg)
#
# 목표:
# 구명보트를 최대한 적게 사용하여 모든 사람을 구출
#
# 입력:
# - people: 사람들의 몸무게를 담은 배열
# - limit: 구명보트의 무게 제한
# 출력:
# - 필요한 구명보트 개수의 최솟값

def solution(people, limit):
    """
    투 포인터(Two Pointer) 알고리즘을 사용한 그리디 접근

    전략:
    1. 몸무게를 오름차순으로 정렬
    2. 가장 가벼운 사람과 가장 무거운 사람을 함께 태울 수 있는지 확인
    3. 함께 탈 수 없다면 무거운 사람만 먼저 태움
    """
    # 1. 몸무게를 오름차순으로 정렬
    people.sort()
    # 예시: [70, 50, 80, 50] → [50, 50, 70, 80]

    # 2. 투 포인터 초기화
    lightest_idx = 0  # 가장 가벼운 사람의 인덱스
    heaviest_idx = len(people) - 1  # 가장 무거운 사람의 인덱스
    boat_count = 0  # 필요한 보트의 수

    # 3. 모든 사람을 태울 때까지 반복
    while lightest_idx <= heaviest_idx:
        # 가장 가벼운 사람 + 가장 무거운 사람이 함께 탈 수 있는지 확인
        if people[lightest_idx] + people[heaviest_idx] <= limit:
            lightest_idx += 1  # 가벼운 사람도 태움

        # 무거운 사람은 무조건 탑승
        heaviest_idx -= 1

        # 보트 1대 사용
        boat_count += 1

    return boat_count

# 테스트
print(solution([70, 50, 80, 50], 100))  # 예상 출력: 3
# 과정: [50, 50, 70, 80] → (50+50), (70), (80) = 3대


# ============================================
# 문제 2: 귤 고르기 (Greedy Algorithm)
# ============================================
# 문제 설명:
# 경화는 과수원에서 귤을 수확했습니다.
# 경화는 수확한 귤 중 k개를 골라 상자 하나에 담아 판매하려고 합니다.
# 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한
# 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다.
#
# 예제:
# - 수확한 귤 8개의 크기: [1, 3, 2, 5, 4, 5, 2, 3]
# - 판매하려는 귤 개수: 6개
# - 크기별 개수: {1:1개, 2:2개, 3:2개, 4:1개, 5:2개}
# - 최적 선택: 크기 2(2개), 3(2개), 5(2개) → 총 3종류
# - 크기 1, 4를 제외하면 6개를 담을 수 있고, 종류는 3가지로 최소
#
# 입력:
# - k: 담으려는 귤의 개수
# - tangerine: 귤의 크기를 담은 배열
# 출력:
# - 크기가 서로 다른 종류의 수의 최솟값

from collections import Counter

def solution(k, tangerine):
    """
    그리디 알고리즘: 가장 개수가 많은 크기부터 선택

    전략:
    1. 귤 크기별 개수를 카운트
    2. 개수가 많은 순서대로 정렬
    3. 개수가 많은 크기부터 k개가 될 때까지 선택
    """
    # 1. 귤 크기별 개수 카운트
    size_count = Counter(tangerine)
    # 예시: [1, 3, 2, 5, 4, 5, 2, 3] → {1:1, 2:2, 3:2, 4:1, 5:2}

    # 2. 개수가 많은 순서대로 정렬 (내림차순)
    sorted_counts = sorted(size_count.values(), reverse=True)
    # 예시: [2, 2, 2, 1, 1]

    total_tangerines = 0  # 지금까지 담은 귤 개수
    tangerine_types = 0  # 선택된 귤 종류 수

    # 3. 개수가 많은 크기부터 k개가 될 때까지 선택
    for count in sorted_counts:
        total_tangerines += count  # 해당 크기 귤을 모두 담기
        tangerine_types += 1  # 귤 종류 +1

        # 원하는 개수(k개) 이상 담았다면 종료
        if total_tangerines >= k:
            break

    return tangerine_types

# 테스트
print(solution(6, [1, 3, 2, 5, 4, 5, 2, 3]))  # 예상 출력: 3
# 과정: 크기별 개수 {1:1, 2:2, 3:2, 4:1, 5:2}
#       → [2, 2, 2]개씩 선택 → 6개, 3종류

print(solution(4, [1, 3, 2, 5, 4, 5, 2, 3]))  # 예상 출력: 2
# 과정: 크기별 개수 {1:1, 2:2, 3:2, 4:1, 5:2}
#       → [2, 2]개씩 선택 → 4개, 2종류


# ============================================
# 문제 3: 멀리 뛰기 (Dynamic Programming)
# ============================================
# 문제 설명:
# 효진이는 멀리 뛰기를 연습하고 있습니다.
# 효진이는 한번에 1칸 또는 2칸을 뛸 수 있습니다.
# 멀리뛰기에 사용될 칸의 수 n이 주어질 때,
# 효진이가 끝에 도달하는 방법이 몇 가지인지 구하는 문제입니다.
# (결과를 1234567로 나눈 나머지를 반환)
#
# 예제 분석 (패턴 찾기):
# 1칸 => 1가지
#   (1)
#
# 2칸 => 2가지
#   (1+1), (2)
#
# 3칸 => 3가지
#   (1+1+1), (1+2), (2+1)
#
# 4칸 => 5가지
#   (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2)
#
# 5칸 => 8가지
#   (1+1+1+1+1)
#   (1+1+1+2), (1+1+2+1), (1+2+1+1), (2+1+1+1)
#   (1+2+2), (2+1+2), (2+2+1)
#
# 패턴 발견: 1, 2, 3, 5, 8, 13, 21, ...
# → 피보나치 수열! (점화식: dp[n] = dp[n-1] + dp[n-2])
#
# 이유:
# - n칸에 도달하는 방법 = (n-1)칸에서 1칸 뛰기 + (n-2)칸에서 2칸 뛰기
#
# 입력: n (칸의 수)
# 출력: 끝에 도달하는 방법의 수를 1234567로 나눈 나머지

def solution(n):
    """
    동적 프로그래밍: 피보나치 수열 패턴

    점화식: dp[i] = dp[i-1] + dp[i-2]
    - dp[i]: i칸에 도달하는 방법의 수
    - i번째 칸은 (i-1)칸에서 1칸 뛰거나, (i-2)칸에서 2칸 뛰어서 도달
    """
    # 1. DP 테이블 생성 (0번 인덱스부터 사용)
    dp = [0] * (n + 1)

    # 2. 기본값 설정 (Base Case)
    dp[0] = 1  # 0칸: 1가지 (아무것도 안 뛰기)
    dp[1] = 1  # 1칸: 1가지 (1칸 뛰기)
    if n >= 2:
        dp[2] = 2  # 2칸: 2가지 (1+1 또는 2)

    # 3. 피보나치 수열 형태로 계산
    for i in range(3, n + 1):
        # i칸 = (i-1)칸에서 1칸 뛰기 + (i-2)칸에서 2칸 뛰기
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1234567

    return dp[n]

# 테스트
print(solution(4))  # 예상 출력: 5
# 과정: dp = [1, 1, 2, 3, 5]

print(solution(5))  # 예상 출력: 8
# 과정: dp = [1, 1, 2, 3, 5, 8]

# ============================================
# 💡 핵심 정리
# ============================================
# 문제 1 (구명보트): 투 포인터, 그리디 - 가벼운 사람과 무거운 사람 매칭
# 문제 2 (귤 고르기): 그리디 - 개수가 많은 것부터 선택
# 문제 3 (멀리 뛰기): 동적 프로그래밍 - 피보나치 수열 패턴
#
# 시간 복잡도:
# - 문제 1: O(n log n) - 정렬
# - 문제 2: O(n log n) - Counter + 정렬
# - 문제 3: O(n) - DP 테이블 채우기