# 1. NumPy란?
'''
    NumPy
    - 과학계산을 위한 핵심 라이브러리
    - 데이터 과학, 머신러닝, 과학 연구 분야에 가장 중요한 도구
    
    주요특징
    1) 다차원 배열 객체(ndarray)
    2) 빠른 연산 속도
    3) 메모리 효율성
    4) 벡터화 연산 지원
    5) 선형대수, 푸리에 변환, 난수 생성 등 다양한 수학 함수 제공
'''

# 2. 왜 NumPy를 사용해야 하는가?
'''
    문제점
    - 파이썬은 인터프리터 언어로 실행속도가 느림

    해결책
    - 바로 NumPy!
        해결책 1) - 속도개선
        - NumPy는 C언어로 구현되어 있어 대용량 데이터를 매우 빠르게 처리
        - 일반 파이썬 리스트보다 10~100배 이상 빠름

        해결책 2) - 메모리 효율성
        - 파이썬 리스트 : 각 요소가 객체로 되어있어 메모리 오버헤드가 큼
            예) [1, 2, 3] 각 숫자가 별도의 파이썬 객체 형태로 저장
        - NumPy 배열 : 연속된 메모리 공간에 "같은 타입의 데이터를 저장"
            예) np.array([1, 2, 3]) -> 연속된 메모리 공간에 정수만 저장

        해결책 3) - 벡터화 연산
        - 반복문 없이 전체 배열에 대한 연산을 한번에 수행
        - 코드가 간결하고 가독성이 좋음
'''
print('==============================================================')
print('2. 왜 NumPy를 사용해야 하는가?')
print('<NumPy 임포트 및 버전, 설치경로 확인>')
import numpy as np # NumPy 임포트
print('버전 확인 : ', np.__version__)
print('설치 경로 : ', np.__file__)

r'''
    <NumPy 임포트 및 버전, 설치경로 확인>
    버전 확인 :  2.3.3
    설치 경로 :  C:\Users\gy\Desktop\kdt4\venv\Lib\site-packages\numpy\__init__.py
'''

# 3. ndarray - NumPy의 핵심 자료구조
'''
    ndarray
    - NumPy의 핵심 자료구조
    - "같은 타입의 요소들"을 담는 다차원 컨테이너
    - 고정된 크기의 "동질적" 배열

    핵심 속성
    - dtype : 배열 요소의 데이터 타입
    - shape : 배열의 형태(각 차원의 크기)
    - ndim : 배열의 차원 수
    - size : 배열 전체의 요소 개수
    - itemsize : 각 요소의 바이트 크기
'''
print('==============================================================')
print('3. ndarray - NumPy의 핵심 자료구조')
print('<ndarray의 핵심 속성>')
arr = np.array([1, 2, 3, 4, 5])
print('arr.dtype(데이터 타입) : ', arr.dtype)
print('arr.shape(모양) : ', arr.shape)
print('arr.ndim(차원 수) : ', arr.ndim)
print('arr.size(요소 개수) : ', arr.size)
print('arr.itemsize(각 요소 바이트 크기) : ', arr.itemsize)
'''
    < ndarray의 핵심 속성 >
    arr.dtype(데이터 타입) :  int64
    arr.shape(모양) :  (5,)
    arr.ndim(차원 수) :  1
    arr.size(요소 개수) :  5
    arr.itemsize(각 요소 바이트 크기) :  8
'''

# 4. 파이썬 리스트 vs NumPy 배열
'''
    차이점
        차이점 1) - 타입 고정성
            파이썬 리스트
            - "서로 다른 타입의 요소들"을 담을 수 있음(이질적)
            - 각 요소가 독립적인 파이썬 객체
            - 유연하지만 메모리와 속도 측면에서 비효율적

            NumPy 배열
            - "모든 요소가 같은 타입"이어야 함(동질적)
            - 다른 타입이 섞이면 자동으로 상위 타입으로 변환됨
            - 변환 우선순위
                - bool < int < float < complex < string
        
        차이점 2) - 연산 방식
            파이썬 리스트의 "+" 연산
            - 리스트 연결

            NumPy 배열의 "+" 연산
            - 요소별 연산
            - 벡터화 연산으로 매우 바름        
'''
print('==============================================================')
print('4. 파이썬 리스트 vs NumPy 배열')
print('<파이썬 리스트 vs NumPy 배열 / 차이점 1) - 타입 고정성>')
python_list  = [1, 2.5, '3', True] # 다양한 타입을 담을 수 있음
numpy_array = np.array([1, 2, 3, True]) # [1, 2, 3, 1] - 모두 정수로 동일해짐
print('파이썬 리스트 : ',python_list)
print('NumPy 배열', numpy_array)
print()
'''
    <파이썬 리스트 vs NumPy 배열 / 차이점 1) - 타입 고정성>
    파이썬 리스트 :  [1, 2.5, '3', True]
    NumPy 배열 [1 2 3 1]
'''

print('<파이썬 리스트 vs NumPy 배열 / 차이점 2) - 연산 방식>')
python_list1 = [1, 2, 3]
python_list2 = [4, 5, 6]
numpy_array1 = np.array([1, 2, 3])
numpy_array2 = np.array([4, 5, 6])
print('파이썬 리스트 "+" 연산 : ', python_list1 + python_list2) # 리스트 연결
print('NumPy 배열 "+" 연산 : ', numpy_array1 + numpy_array2) # 요소별 연산
'''
    <파이썬 리스트 vs NumPy 배열 / 차이점 2) - 연산 방식>
    파이썬 리스트 "+" 연산 :  [1, 2, 3, 4, 5, 6]
    NumPy 배열 "+" 연산 :  [5 7 9]
'''

# 5. 다양한 데이터 타입의 배열 생성
'''
    NumPy는 다양한 데이터 타입을 지원함
    - 정수형 : int8, int16, int32, int64
    - 부동소수점 : float16, float32, float64
    - 복소수 : complex64, complex128
    - 불린 : bool
    - 문자열 : string_, unicode_
'''
print('==============================================================')
print('5. 다양한 데이터 타입의 배열 생성')
print('<정수 배열>')
int_array = np.array([1, 2, 3, 4, 5])
print(int_array)
print(int_array.dtype)
print()
'''
    <정수 배열>
    [1 2 3 4 5]
    int64 (시스템에 따라 다를 수 있음)
'''

print('<실수 배열 - 실수가 하나라도 포함되면 실수로 변환 됨>')
float_array = np.array([1.1, 2, 3, 4, 5])
print(float_array)
print(float_array.dtype)
print()
'''
    <실수 배열 - 실수가 하나라도 포함되면 실수로 변환 됨>
    [1.1 2.  3.  4.  5. ]
    float64
'''

print('<문자열 배열>')
string_array = np.array(['apple', 'banana', 'cherry', 'administrator'])
print(string_array)
print(string_array.dtype)
print()
'''
    <문자열 배열>
    ['apple' 'banana' 'cherry' 'administrator']
    <U13

    <U13 의미
    - < : littie-endian (바이트 순서)
    - U : 유니코드 문자열
    - 13 : 최대 문자 길이 (여기서는 administrator 길이)
'''

print('<명시적 타입 지정>')
specified_array = np.array(['1', '2', 3, 4, 5], dtype = np.float32)
print(specified_array)
print(specified_array.dtype)
print()
'''
    <명시적 타입 지정>
    [1. 2. 3. 4. 5.]
    float32
'''

# 6. 다차원 배열
'''
    - 1차원 배열 : 벡터(Vector)
    - 2차원 배열 : 행렬(matrix)
    - 3차원 배열 : 텐서(tensor
    - 4차원 이상 : 고차원 배열
'''
print('==============================================================')
print('6. 다차원 배열')
print('<2차원 배열 행렬>')
matrix = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])
print(matrix)
print('matrix.shape : ', matrix.shape)
print('matrix.ndim : ', matrix.ndim)
print('matrix.size : ',matrix.size)
print()
'''
    <2차원 배열 행렬>
    [[1 2 3]
    [4 5 6]
    [7 8 9]]
    matrix.shape :  (3, 3)
    matrix.ndim :  2
    matrix.size :  9
'''

print('<3차원 배열 텐서>')
tensor = np.array([
	[
		[1, 2, 3, 4],
		[5, 6, 7, 8],
		[9, 10, 11, 12]
	],
	[
		[13, 14, 15, 16],
		[17, 18, 19, 20],
		[21, 22, 23, 24]
	]
])
print(tensor)
print('tensor.shape : ', tensor.shape)
print('tensor.ndim : ', tensor.ndim)
print('tensor.size : ', tensor.size)
print()
'''
    <3차원 배열 텐서>
    [[[ 1  2  3  4]
    [ 5  6  7  8]
    [ 9 10 11 12]]

    [[13 14 15 16]
    [17 18 19 20]
    [21 22 23 24]]]
    tensor.shape :  (2, 3, 4)
    tensor.ndim :  3
    tensor.size :  24

    3차원 배열의 이해
    - 여러 개의 2차원 행렬을 쌓은 형태
    - 이미지 처리 (높이, 너비, 색상채널)
    - 동영상 처리 (프레임, 높이, 너비)
    - 딥러닝 (배치크기, 높이, 너비)
'''

# 7. 내장 함수로 배열 생성
print('==============================================================')
print('7. 내장 함수로 배열 생성')
'''
    연속된 숫자 배열 - np.arange(start, stop, step)
    - 파이썬 range()와 유사하지만 NumPy 배열 반환
    - stop 값은 포함하지 않음
    - step에 실수 사용가능!
'''
print('<연속된 숫자 배열 - np.arange(start, stop, step)>')
print('0 ~ 10미만 : ',np.arange(10))
print('1 ~ 11미만 : ', np.arange(1, 11))
print('1 ~ 21미만 홀수만 : ', np.arange(1, 21, 2))
print('1 ~ 11미만 0.5 단위로 : ',np.arange(1, 11, 0.5))
print()
'''
    <연속된 숫자 배열 - np.arange(start, stop, step)>
    0 ~ 10미만 :  [0 1 2 3 4 5 6 7 8 9]
    1 ~ 11미만 :  [ 1  2  3  4  5  6  7  8  9 10]
    1 ~ 21미만 홀수만 :  [ 1  3  5  7  9 11 13 15 17 19]
    1 ~ 11미만 0.5 단위로 :  [ 1.   1.5  2.   2.5  3.   3.5  4.   4.5  5.   5.5  6.   6.5  7.   7.5
    8.   8.5  9.   9.5 10.  10.5]
'''

'''
    균등 간격 배열 - np.linspace(start, stop, num, endpoint=True)
    - 시작과 끝 사이를 균등하게 나눈 배열
    - num : 생성할 요소 개수
    - endpoint=True : 끝 값 포함(기본)
    - endpoint=False : 끝 값 미포함

    endpoint 계산 공식
    endpoint=True : step = (stop - start) / (num - 1) # 기본
    endpoint=False : step = (stop - start) / num

    사용 예시
    - 그래프 그리기(x축 좌표 생성)
    - 수치해석 (등간격 샘플링)
    - 신호처리 (시간 축 생성)
'''
print('<균등 간격 배열 - np.linspace(start, stop, num, endpoint=True)>')
print('endpoint=True(기본) : ', np.linspace(0, 10, 5))
print('endpoint=False : ', np.linspace(0, 10, 5, endpoint=False))
print()
'''
    <균등 간격 배열 - np.linspace(start, stop, num, endpoint=True)>        
    endpoint=True(기본) :  [ 0.   2.5  5.   7.5 10. ]
    endpoint=False :  [0. 2. 4. 6. 8.]
'''

'''
    0으로 채운 배열 - np.zeros(n), np.zeros((n, m)), np.zeros_like(arr)

    용도
    - 배열 초기화
    - 누적 계산용 배열 준비
    - 이미지 처리(검은색 이미지 생성)
'''
print('<0으로 채운 배열 - np.zeros(n), np.zeros((n, m)), np.zeros_like(arr)>')
zeros_1d = np.zeros(5)
zeros_2d = np.zeros((3, 4))
zeros_2d_int = np.zeros((3, 4), dtype=int)
zeros_like = np.zeros_like([
                            [1, 2, 3],
                            [4, 5, 6],
                            [7, 8, 9]
                          ])
print('1차원 : ', zeros_1d)
print('2차원 : \n', zeros_2d)
print('2차원 정수 : \n', zeros_2d_int)
print('zeros_like : \n', zeros_like)
print()
'''
    <0으로 채운 배열 - np.zeros(n), np.zeros((n, m)), np.zeros_like(arr)>
    1차원 :  [0. 0. 0. 0. 0.]
    2차원 :
    [[0. 0. 0. 0.]
    [0. 0. 0. 0.]
    [0. 0. 0. 0.]]
    2차원 : 정수
    [[0 0 0 0]
    [0 0 0 0]
    [0 0 0 0]]
    zeros_like :
    [[0 0 0]
    [0 0 0]
    [0 0 0]]
'''

'''
    1로 채운 배열 - np.ones(n), np.ones((n, m)), np.ones_like(arr)
    
    용도
    - 가중치 초기화
    - 마스크 배열 초기화
    - 곱셈 항등원
'''
print('<1로 채운 배열 - np.ones(n), np.ones((n, m)), np.ones_like(arr)>')
ones_1d = np.ones(5)
ones_2d = np.ones((4, 5))
ones_2d_bool = np.ones((4, 5), dtype=bool)
ones_like = np.ones_like([
                            [1, 2, 3],
                            [4, 5, 6],
                            [7, 8, 9]
                         ])
print('1차원 : ', ones_1d)
print('2차원 : \n', ones_2d)
print('2차원 불린 : \n', ones_2d_bool)
print('ones_like : \n', ones_like)
print()
'''
    <1로 채운 배열 - np.ones(n), np.ones((n, m)), np.ones_like(arr)>
    1차원 :  [1. 1. 1. 1. 1.]
    2차원 :
    [[1. 1. 1. 1. 1.]
    [1. 1. 1. 1. 1.]
    [1. 1. 1. 1. 1.]
    [1. 1. 1. 1. 1.]]
    2차원 불린:
    [[ True  True  True  True  True]
    [ True  True  True  True  True]
    [ True  True  True  True  True]
    [ True  True  True  True  True]]
    ones_like :
    [[1 1 1]
    [1 1 1]
    [1 1 1]]
'''

'''
    특정 값으로 채운 배열 - np.full(n, value), np.full((n,m), value), np.full_like(arr, value)

    용도
    - 초기 값이 있는 배열 생성
    - 기본 값 설정
'''
print('<특정 값으로 채운 배열 - np.full(n, value), np.full((n,m), value), np.full_like(arr, value)>')
full_array = np.full((3, 4), 7)
full_like = np.full_like([
                            [1, 2, 3],
                            [4, 5, 6],
                            [7, 8, 9]
                         ],
                         999)

print('7로 채운 배열 : \n', full_array)
print('full_like 999 : \n', full_like)
print()
'''
    <특정 값으로 채운 배열 - np.full(n, value), np.full((n,m), value), np.full_like(arr, value)>
    7로 채운 배열 :
    [[7 7 7 7]
    [7 7 7 7]
    [7 7 7 7]]
    full_like 999 :
    [[999 999 999]
    [999 999 999]
    [999 999 999]]
'''

# 8. 난수 생성
print('==============================================================')
print('8. 난수 생성')
'''
    균일 분포 난수 - np.random.rand(n, m), np.random.uniform(low=최소, high=최대, size=(n, m))

    균일 분포
    - 특정 구간에서 모든 값이 똑같은 확률로 나옴
    - 치우침 없이 고르게 퍼져있는 확률 분포

    사용 예)
    - 게임 개발(랜덤 아이템 드롭)
    - 시뮬레이션(몬테카를로 방법)
    - 초기화(가중치 랜덤 초기화)
'''
print('<0 ~ 1 균일 분포 난수>')
for i in range(10):
    print('0 ~ 1 균일 : ', np.random.rand(2, 3))
print()
print('<0 ~ 100 균일 분포 난수>')
for i in range(10):
    print('0 ~ 100 : ', np.random.uniform(low=0, high=100, size=(2, 3)))
print()
'''
    <0 ~ 1 균일 분포 난수>
    0 ~ 1 균일 :  [[0.52229327 0.12789327 0.6284996 ]
    [0.92497942 0.50888705 0.54191658]]
    0 ~ 1 균일 :  [[0.12338461 0.55744847 0.10698155]
    [0.50209718 0.93002639 0.12804221]]
    0 ~ 1 균일 :  [[0.06592948 0.08665509 0.78796655]
    [0.69203032 0.21544709 0.78097981]]
    0 ~ 1 균일 :  [[0.19848631 0.50693575 0.84411289]
    [0.74740226 0.77067294 0.51863145]]
    0 ~ 1 균일 :  [[0.0037106  0.61535134 0.13914252]
    [0.40246493 0.34672216 0.59904973]]
    0 ~ 1 균일 :  [[0.24512631 0.79081061 0.40412167]
    [0.61334542 0.58392259 0.49687617]]
    0 ~ 1 균일 :  [[0.97683917 0.46030534 0.63235196]
    [0.13233628 0.28998632 0.56532443]]
    0 ~ 1 균일 :  [[0.28190065 0.40768026 0.44263968]
    [0.28794363 0.2060715  0.62079277]]
    0 ~ 1 균일 :  [[0.46810009 0.20807039 0.93002581]
    [0.61904626 0.11684171 0.42628273]]
    0 ~ 1 균일 :  [[0.59507249 0.35332942 0.92673544]
    [0.68489161 0.5525633  0.1085788 ]]

    <0 ~ 100 균일 분포 난수>
    0 ~ 100 :  [[58.72648949 59.55632109 50.28584445]
    [90.73778293 90.19538396 97.01441063]]
    0 ~ 100 :  [[21.12831497 67.92951347 11.38166484]
    [ 0.1422963  97.07655799 37.93794478]]
    0 ~ 100 :  [[64.29724399 48.88750256 73.03516109]
    [58.0339972  79.06661109 57.95910769]]
    0 ~ 100 :  [[85.01064032 23.55320655 19.39782467]
    [80.9860429  59.70662752  1.28477419]]
    0 ~ 100 :  [[69.84780086  5.7094399   0.23974071]
    [72.48288575 43.74308297 27.62024945]]
    0 ~ 100 :  [[48.52617673  6.9498342  77.39131589]
    [16.25500563 59.74593409 94.7041547 ]]
    0 ~ 100 :  [[56.0554421  67.82612917  1.09917321]
    [20.50956632 53.64164535 51.51520021]]
    0 ~ 100 :  [[19.11008682 68.26680052 24.33877014]
    [19.86305808 40.10942772 89.39835221]]
    0 ~ 100 :  [[49.27618529 72.37379488 29.10634394]
    [27.74242901 38.05828037 95.78955426]]
    0 ~ 100 :  [[62.70781556 10.10764042 36.73891425]
    [41.76450602 55.8577414  84.21255197]]
'''


'''
    정규 분포 난수 - np.random.randn(n, m), np.random.normal(loc=평균, scale=표준편차, size=(n, m))

    정규 분포
    - 평균을 중심으로 좌/우 대칭 종 모양 분포
    - 자연계의 많은 현상이 정규분포를 따름
    - 표준 정규 분포 : 평균 0, 표준편차 1

    68-95-99.7 규칙
    - 평균 ± 1σ: 68% 데이터
    - 평균 ± 2σ: 95% 데이터
    - 평균 ± 3σ: 99.7% 데이터

    사용 예)
    - 실제데이터 시뮬레이션 (키, 몸무게, 시험 점수)
    - 머신러닝 가중치 초기화
    - 노이즈 추가
'''
print('<평균 0, 표준편차 1 - 정규 분포 난수>')
for i in range(10):
    print('평균 0, 표준편차 1 : ', np.random.randn(3, 3))
print()
print('<평균 170, 표준편차 7 - 정규 분포 난수>')
for i in range(10):
    print('평균 170, 표준편차 7 : ', np.random.normal(loc=170, scale=7, size=(2,4)))
print()
'''
    <평균 0, 표준편차 1 - 정규 분포 난수>
    평균 0, 표준편차 1 :  [[ 0.53584817 -0.21009098 -0.0900521 ]
    [-0.12768497  0.08420477 -2.05842056]
    [ 0.88411691  0.68430926  0.61299418]]
    평균 0, 표준편차 1 :  [[ 1.1152482  -0.89271385 -0.01081981]
    [ 1.06883088 -1.02481092  0.16988583]
    [ 0.80867355 -0.3213831  -0.61917929]]
    평균 0, 표준편차 1 :  [[-0.17752415 -0.42589037 -0.24238781]
    [ 0.58118938 -0.30466486  2.10139641]
    [-0.36727529  0.43116291  0.26334825]]
    평균 0, 표준편차 1 :  [[ 0.76056403  0.47805228  0.3488691 ]
    [-0.51040995 -0.66545693 -0.01510115]
    [ 0.2391507   0.79592478  1.29161555]]
    평균 0, 표준편차 1 :  [[ 1.5091219  -1.18979624 -0.10442765]
    [ 2.67313262 -0.56497306  0.40868128]
    [ 0.63718671 -0.66875739 -1.32646103]]
    평균 0, 표준편차 1 :  [[ 1.12935658  2.39646398  0.28225779]
    [ 2.26320033  0.73048907 -1.06449243]
    [ 1.21419615  0.63132212  0.83318486]]
    평균 0, 표준편차 1 :  [[ 0.34679225 -0.08317737  0.94444233]
    [ 0.23364642  0.67145535  0.36411157]
    [-0.40025261  1.16021674 -1.06234199]]
    평균 0, 표준편차 1 :  [[ 0.7612522   0.39608531  1.21468195]
    [ 0.92788147 -1.33625071 -0.38961903]
    [-0.29102538 -1.27171368  0.38648897]]
    평균 0, 표준편차 1 :  [[-1.34102027 -0.61447868  2.1563365 ]
    [ 2.16024176  0.04689808 -0.21432693]
    [ 1.11514649 -0.36755271  0.11004028]]
    평균 0, 표준편차 1 :  [[ 1.2677977   0.02358942 -0.96222172]
    [ 0.85960761 -0.87623401  0.30392165]
    [ 2.52879326  0.01608657 -0.48611915]]

    <평균 170, 표준편차 7 - 정규 분포 난수>
    평균 170, 표준편차 7 :  [[169.01604531 172.33713471 176.5742071  155.73117694]
    [157.24323556 156.99231622 168.73670796 159.80604384]]
    평균 170, 표준편차 7 :  [[171.46379117 167.90725496 163.29880751 168.00292479]
    [163.51304571 170.64407775 154.30019626 169.87035736]]
    평균 170, 표준편차 7 :  [[157.94393057 161.55475608 153.32059243 174.33354374]
    [157.64433418 166.80290626 174.0960003  167.06870967]]
    평균 170, 표준편차 7 :  [[164.22738683 187.44505776 173.03384577 174.3706895 ]
    [176.95476546 167.84873303 173.39842644 166.53885128]]
    평균 170, 표준편차 7 :  [[179.76635859 167.45588911 160.12914589 164.96350216]
    [166.74413715 171.82449553 164.59545959 171.28159511]]
    평균 170, 표준편차 7 :  [[169.01365544 171.40360876 170.01970218 176.8799086 ]
    [179.22503852 179.18388914 170.27159904 174.28394254]]
    평균 170, 표준편차 7 :  [[175.00541011 167.22440421 164.38270812 170.71504752]
    [177.42316663 169.97748576 170.81709414 163.62538304]]
    평균 170, 표준편차 7 :  [[178.3392493  159.3602835  174.15431251 165.644939  ]
    [166.7404439  173.0691705  166.99231637 183.03354801]]
    평균 170, 표준편차 7 :  [[168.24039688 161.14133172 166.34328924 163.77623977]
    [167.105723   159.80928002 174.45156947 167.24507228]]
    평균 170, 표준편차 7 :  [[161.81179073 171.2819847  177.22787545 171.7121721 ]
    [168.59797338 164.58718543 170.59760681 165.9708822 ]]
'''


'''
    정수 난수 - np.random.randint(low=1, high=100, size=(2,3))

    - low 이상, high 미만의 정수
    - 이산 균일 분포

    사용 예)
    - 게임(주사위, 카드)
    - 랜덤 샘플링
    - 랜덤 인덱스 생성
'''
print('<0 ~ 9 - 정수 난수>')
for i in range(10):
    print('0 ~ 9 정수 난수 : ', np.random.randint(0, 10, size=10))
print()
'''
    <0 ~ 9 - 정수 난수>
    0 ~ 9 정수 난수 :  [6 5 0 3 3 9 4 8 5 8]
    0 ~ 9 정수 난수 :  [9 3 9 9 4 6 2 1 6 9]
    0 ~ 9 정수 난수 :  [6 9 3 3 3 3 0 9 9 1]
    0 ~ 9 정수 난수 :  [5 2 1 0 6 1 0 7 1 0]
    0 ~ 9 정수 난수 :  [3 5 3 7 7 9 5 8 7 9]
    0 ~ 9 정수 난수 :  [4 2 2 2 1 1 6 4 0 9]
    0 ~ 9 정수 난수 :  [9 7 6 7 6 7 1 5 9 8]
    0 ~ 9 정수 난수 :  [3 1 4 5 2 4 2 2 5 7]
    0 ~ 9 정수 난수 :  [2 1 0 7 2 0 3 6 8 8]
    0 ~ 9 정수 난수 :  [2 0 4 5 6 0 8 9 4 5]
'''


'''
    재현 가능한 난수(시드 설정)
    
    시드(Seed)
    - 난수 생성의 시작점
    - 같은 시드 = 같은 난수 시퀀스
    - 디버깅과 재현성을 위해 중요
    
    사용시기
    - 실험 재현
    - 디버깅
    - 테스트 코드 작성
'''
print('<재현 가능한 난수(시드 설정)>')
np.random.seed(42) # 시드 고정
random_arr1 = np.random.rand(5)
print('첫번째 랜덤 배열 : ', random_arr1)
np.random.seed(42) # 같은 시드 사용
random_arr2 = np.random.rand(5)
print('두번째 랜덤 배열 : ', random_arr1)
print('같은 배열 인가요? : ', np.array_equal(random_arr1, random_arr2))
print()
'''
    <재현 가능한 난수(시드 설정)>
    첫번째 랜덤 배열 :  [0.37454012 0.95071431 0.73199394 0.59865848 0.15601864]
    두번째 랜덤 배열 :  [0.37454012 0.95071431 0.73199394 0.59865848 0.15601864]
    같은 배열 인가요? :  True
'''


'''
    새로운 난수 생성 방식(권장)

    default_rng(Random Number Generator)
    - numpy 1.17 이상에서 권장하는 방식
    - 더 나은 성능과 통계적 품질
    - 여러 Generator를 독립적으로 사용 가능

    장점
    - 스레드 안정성
    - 더 빠른 속도
    - 더 좋은 난수 품질
'''

print('<새로운 난수 생성 방식(권장)>')
rng = np.random.default_rng(42)
random3 = rng.random((2, 3)) # 0~1 균일 분포
print(random3)
# 독립적인 generator 생성
rng1 = np.random.default_rng(seed=42)
rng2 = np.random.default_rng(seed=42)
random_rng1 = rng1.random(3)
random_rng2 = rng2.random(3)
print('독립적 generator 1 : ', random_rng1)
print('독립적 generator 1 : ', rng1.random(3))
print('독립적 generator 2 : ', random_rng2)
print('독립적 generator 2 : ', rng2.random(3))
print('같은 배열 인가요? : ', np.array_equal(random_rng1, random_rng2))
'''
    <새로운 난수 생성 방식(권장)>
    [[0.77395605 0.43887844 0.85859792]
    [0.69736803 0.09417735 0.97562235]]
    독립적 generator 1 :  [0.77395605 0.43887844 0.85859792]
    독립적 generator 1 :  [0.69736803 0.09417735 0.97562235]
    독립적 generator 2 :  [0.77395605 0.43887844 0.85859792]
    독립적 generator 2 :  [0.69736803 0.09417735 0.97562235]
    같은 배열 인가요? :  True
'''

# 9. 배열의 형태 변경
print('==============================================================')
print('9. 배열의 형태 변경')
'''
    배열의 형태 변경 - numpy_array.reshape(new_shape), np.reshape(numpy_array, new_shape)

    중요
    - 전체 요소 개수는 변하지 않음
    - 원본 배열은 변경되지 않음
    - -1을 사용하면 자동으로 크기 계산
'''
print('<1차원 -> 2차원 변환>')
arr = np.arange(12)
print('1차원 : ', arr)
print('2차원 : \n', arr.reshape(3, 4))
print()
'''
    <1차원 -> 2차원 변환>
    1차원 :  [ 0  1  2  3  4  5  6  7  8  9 10 11]
    2차원 :
    [[ 0  1  2  3]
    [ 4  5  6  7]
    [ 8  9 10 11]]
'''

print('<다양한 형태로 변환>')
arr = np.arange(24)
print('1차원 : ', arr)
print('2x12 : \n', np.reshape(arr, (2, 12)))
print('4x6 : \n', np.reshape(arr, (4, 6)))
print('6x4 : \n', arr.reshape(6, 4))
print()
'''
    <다양한 형태로 변환>
    1차원 :  [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
    2x12 :
    [[ 0  1  2  3  4  5  6  7  8  9 10 11]
    [12 13 14 15 16 17 18 19 20 21 22 23]]
    4x6 :
    [[ 0  1  2  3  4  5]
    [ 6  7  8  9 10 11]
    [12 13 14 15 16 17]
    [18 19 20 21 22 23]]
    6x4 :
    [[ 0  1  2  3]
    [ 4  5  6  7]
    [ 8  9 10 11]
    [12 13 14 15]
    [16 17 18 19]
    [20 21 22 23]]
'''

print('<3차원으로 변환>')
arr = np.arange(24)
print('1차원 : ', arr)
print('3차원 : \n', arr.reshape(2, 3, 4))
print()
'''
    <3차원으로 변환>
    1차원 :  [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
    3차원 :
    [[[ 0  1  2  3]
    [ 4  5  6  7]
    [ 8  9 10 11]]

    [[12 13 14 15]
    [16 17 18 19]
    [20 21 22 23]]]
'''

print('<-1 사용 : 자동 크기 계산>')
'''
    -1의 의미
    - 나머지를 자동으로 계산
    - 한 차원에 사용 가능
    - 전체 요소 개수를 기준으로 계산

    사용 예)
    - 12개 요소를 (3, -1)로 reshape -> 12/3 = 4 이므로 (3, 4)가 됨
'''
arr = np.arange(12)
print('(3, -1) \n', arr.reshape(3, -1))
print(f'(3, -1) -> {arr.reshape(3, -1).shape}')
print()
print('(-1, 4) \n', arr.reshape(-1, 4))
print(f'(-1, 4) -> {arr.reshape(-1, 4).shape}')
print()
print('(2, 2, -1)\n', arr.reshape(2, 2, -1))
print(f'(2, 2, -1) -> {arr.reshape(2, 2, -1).shape}')
print()
'''
    <-1 사용 : 자동 크기 계산>
    (3, -1)
    [[ 0  1  2  3]
    [ 4  5  6  7]
    [ 8  9 10 11]]
    (3, -1) -> (3, 4)

    (-1, 4)
    [[ 0  1  2  3]
    [ 4  5  6  7]
    [ 8  9 10 11]]
    (-1, 4) -> (3, 4)

    (2, 2, -1)
    [[[ 0  1  2]
    [ 3  4  5]]

    [[ 6  7  8]
    [ 9 10 11]]]
    (2, 2, -1) -> (2, 2, 3)
'''


'''
    1차원으로 펼치기
'''
print('<1차원으로 펼치기>')
matrix = np.array([
    [1, 2, 3],
    [4, 5, 6]
])

print('방법 1) matrix.reshape(-1) : \n',matrix.reshape(-1))

# 방법 2) 복사본 생성
print('방법 2) matrix.flatten() : \n',matrix.flatten())

# 방법 3) view 반환(변경시 원본도 변경)
print('방법 3) matrix.ravel() : \n',matrix.ravel())
print()
'''
    <1차원으로 펼치기>
    방법 1) matrix.reshape(-1) :
    [1 2 3 4 5 6]
    방법 2) matrix.flatten() :
    [1 2 3 4 5 6]
    방법 3) matrix.ravel() :
    [1 2 3 4 5 6]
'''

print('<열 벡터, 행 벡터 변환>')
arr = np.array([1, 2, 3, 4, 5])
print('원본 배열:', arr, '| shape:', arr.shape)
row_vector = np.reshape(arr, (1, -1))
print('\n행 벡터:\n', row_vector, '| shape:', row_vector.shape)
col_vector = np.reshape(arr, (-1, 1))
print('\n열 벡터:\n', col_vector, '| shape:', col_vector.shape)
print()
'''
    <열 벡터, 행 벡터 변환>
    원본 배열: [1 2 3 4 5] | shape: (5,)

    행 벡터:
    [[1 2 3 4 5]] | shape: (1, 5)

    열 벡터:
    [[1]
    [2]
    [3]
    [4]
    [5]] | shape: (5, 1)
'''


print('<reshape 오류 예시>')
arr = np.arange(12)
print('배열 크기 : ', arr.size)
try:
    wrong_reshape = arr.reshape(3, 5)  # 3 * 5 = 15 (불가능)
except ValueError as e:
    print('오류 발생:', e)
print()
'''
    <reshape 오류 예시>
    배열 크기 :  12
    오류 발생: cannot reshape array of size 12 into shape (3,5)
'''


print('<newaxis를 사용한 차원 추가>')
'''
    newaxis
    - reshape의 대안
    - 새로운 차원을 추가할 때 더 직관적
    - None과 동일
'''
arr = np.array([1, 2, 3, 4, 5])
row = arr[np.newaxis, :]
print(row, '/', row.shape)
col = arr[:, np.newaxis]
print(col, '/', col.shape)
'''
    <newaxis를 사용한 차원 추가>
    [[1 2 3 4 5]] / (1, 5)
    [[1]
    [2]
    [3]
    [4]
    [5]] / (5, 1)
'''

'''
    reshape 핵심:
    1) 배열의 형태를 변경(전체 요소 개수는 동일)
    2) 원본은 변경하지 않음(새 view 반환)
    3) -1 사용으로 자동 크기 계산 가능
    4) 이미지/텐서 데이터 변환에 필수
    5) flatten(), ravel()로 1D 변환 가능

    주의사항
    - reshape는 요소 개수가 반드시 맞아야 함!
'''