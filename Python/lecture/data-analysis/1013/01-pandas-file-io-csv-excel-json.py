import pandas as pd

# ═══════════════════════════════════════════════════════════════
# CSV (Comma-Separated Values)
# ═══════════════════════════════════════════════════════════════
# CSV는 가장 널리 사용되는 데이터 파일 형식입니다.
# 데이터 분석, 데이터베이스 내보내기/가져오기, 시스템 간 데이터 교환에 주로 사용됩니다.

'''
    CSV의 주요 특징:
    1. 쉼표(,)로 값을 구분 - 각 열(컬럼)이 쉼표로 분리됨
    2. 텍스트 파일이라 메모장, 에디터 등 어디서나 열람 가능
    3. 파일 크기가 가볍고 읽기/쓰기가 빠름
    4. Excel, Google Sheets, 데이터베이스 등 다양한 프로그램과 호환
    5. 서식이나 수식은 포함되지 않고 순수 데이터만 저장
'''

# CSV 파일 예시 내용 (실제 파일 내부 모습)
"""
name,   age,    city,   salary
John,   25,     Seoul,  50000
Jane,   30,     Busan,  60000
Park,   35,     Daegu,  55000
"""

# ─────────────────────────────────────────────────────────────
# 1. CSV 파일 저장하기
# ─────────────────────────────────────────────────────────────

# 샘플 데이터프레임 생성
# DataFrame: 엑셀 시트처럼 행(row)과 열(column)로 구성된 2차원 테이블 구조
sample_data = pd.DataFrame({
    'name': ['John', 'Jane', 'Park'],      # 이름 열
    'age': [25, 30, 35],                   # 나이 열
    '도시': ['서울', '부산', '대구'],        # 도시 열 (한글 컬럼명 사용 가능)
    'salary': [50000, 60000, 55000]        # 급여 열
})

# UTF-8로 CSV 저장 (가장 권장되는 방식)
sample_data.to_csv('sample_data.csv',
                   # index=False: 행 번호(0,1,2...)를 파일에 저장하지 않음
                   index=False,
                   # utf-8-sig: UTF-8 + BOM (Byte Order Mark)
                   encoding='utf-8-sig')
# BOM을 추가하면 Excel에서 한글이 깨지지 않고 정상적으로 표시됨

# CP949로 저장 (Windows 한글 인코딩)
# 구형 Windows 시스템이나 특정 프로그램에서 필요할 때 사용
# sample_data.to_csv('sample_data.csv', index=False, encoding='cp949')

# ─────────────────────────────────────────────────────────────
# 2. CSV 파일 읽기
# ─────────────────────────────────────────────────────────────

# read_csv(): CSV 파일을 읽어서 DataFrame으로 변환
df = pd.read_csv('sample_data.csv', encoding='utf-8-sig')
# 저장할 때 사용한 인코딩과 동일한 인코딩으로 읽어야 함

print('=== CSV 파일 읽기 ===')
print(df)                                  # 전체 데이터프레임 출력
print(f'데이터 타입:\n {df.dtypes}')       # 각 열의 데이터 타입 확인 (int64, object 등)
print(f'데이터 크기:\n {df.shape}')        # (행 개수, 열 개수) 형태로 출력

# ─────────────────────────────────────────────────────────────
# 3. 다른 구분자(delimiter) 사용하기
# ─────────────────────────────────────────────────────────────

# CSV는 기본적으로 쉼표(,)로 구분하지만, 다른 구분자도 사용 가능합니다.
# 예: 탭(\t), 세미콜론(;), 파이프(|) 등

sample_data = pd.DataFrame({
    'name': ['John', 'Jane', 'Park'],
    'age': [25, 30, 35],
    '도시': ['서울', '부산', '대구'],
    'salary': [50000, 60000, 55000]
})

# sep='\t': 탭(Tab) 문자로 구분된 파일 저장
# 주로 .txt 확장자와 함께 사용되며, 탭으로 구분된 값(TSV)이라고 부름
sample_data.to_csv('tab_separated.txt',
                   sep='\t',               # 구분자를 탭으로 설정
                   index=False)

# 탭으로 구분된 파일 읽기
df_tab = pd.read_csv('tab_separated.txt',
                     sep='\t')             # 읽을 때도 동일한 구분자 지정

print('=== CSV sep=탭 파일 읽기 ===')
print(df_tab)
print()
print(df_tab.head())  # head(): 처음 5개 행만 출력 (데이터 미리보기에 유용)
# head(10)처럼 숫자를 지정하면 해당 개수만큼 출력

# ═══════════════════════════════════════════════════════════════
# Excel 파일 다루기
# ═══════════════════════════════════════════════════════════════
# Excel은 마이크로소프트의 스프레드시트 프로그램입니다.
# CSV보다 더 많은 기능을 제공하지만, 파일 크기가 크고 처리 속도가 느릴 수 있습니다.

'''
    Excel의 주요 특징:
    1. 여러 시트(Sheet) 지원 - 하나의 파일에 여러 테이블 저장 가능
    2. 서식(색상, 폰트, 정렬 등), 수식, 차트 포함 가능
    3. 비즈니스 환경에서 가장 많이 사용되는 형식
    4. 확장자: .xlsx (Excel 2007 이후, 최신 버전), .xls (구버전)
    
    주의: Excel 파일을 다루려면 openpyxl 라이브러리 설치 필요
    설치 명령어: pip install openpyxl
'''

# ─────────────────────────────────────────────────────────────
# 4. Excel 파일 저장하기
# ─────────────────────────────────────────────────────────────

sample_data = pd.DataFrame({
    'name': ['John', 'Jane', 'Park'],
    'age': [25, 30, 35],
    '도시': ['서울', '부산', '대구'],
    'salary': [50000, 60000, 55000]
})

# to_excel(): DataFrame을 Excel 파일로 저장
sample_data.to_excel('sample_data.xlsx',
                     index=False,              # 행 번호 제외
                     sheet_name='Default')     # 시트 이름 지정
print('샘플 엑셀 파일 생성 완료')

# ─────────────────────────────────────────────────────────────
# 5. Excel 파일 읽기
# ─────────────────────────────────────────────────────────────

# read_excel(): Excel 파일을 읽어서 DataFrame으로 변환
df_excel = pd.read_excel('sample_data.xlsx')
# 시트 이름을 지정하지 않으면 첫 번째 시트를 자동으로 읽음

print('=== Excel 파일 읽기 ===')
print(df_excel)

# ─────────────────────────────────────────────────────────────
# 6. 여러 시트를 가진 Excel 파일 만들기
# ─────────────────────────────────────────────────────────────

sample_data = pd.DataFrame({
    'name': ['John', 'Jane', 'Park'],
    'age': [25, 30, 35],
    '도시': ['서울', '부산', '대구'],
    'salary': [50000, 60000, 55000]
})

# ExcelWriter: 여러 시트를 하나의 Excel 파일에 저장할 때 사용
# with 문을 사용하면 파일이 자동으로 저장되고 닫힘
with pd.ExcelWriter('multi_sheet.xlsx') as writer:
    # 첫 번째 시트: 전체 데이터
    sample_data.to_excel(writer,
                         sheet_name='Default1',   # 시트 이름
                         index=False)

    # 두 번째 시트: 이름 열만 저장
    sample_data['name'].to_excel(writer,
                                 sheet_name='name',
                                 index=False)

print('2개의 시트를 가진 엑셀 파일 생성 완료')

# 특정 시트 읽기 예시:
# df = pd.read_excel('multi_sheet.xlsx', sheet_name='Default1')
# 모든 시트 읽기 예시:
# all_sheets = pd.read_excel('multi_sheet.xlsx', sheet_name=None)  # 딕셔너리 형태로 반환

# ═══════════════════════════════════════════════════════════════
# JSON (JavaScript Object Notation)
# ═══════════════════════════════════════════════════════════════
# JSON은 웹 API, 설정 파일, 데이터 교환에 널리 사용되는 텍스트 기반 형식입니다.

'''
    JSON의 주요 특징:
    1. 가볍고 읽기 쉬운 텍스트 형식
    2. 웹 개발에서 가장 많이 사용 (REST API 등)
    3. 중첩된 구조(nested structure) 표현 가능
    4. 키-값 쌍(key-value pair)으로 데이터 저장
    5. JavaScript뿐만 아니라 거의 모든 프로그래밍 언어에서 지원
'''

# ─────────────────────────────────────────────────────────────
# 7. JSON 파일 저장하기
# ─────────────────────────────────────────────────────────────

sample_data = pd.DataFrame({
    'name': ['John', 'Jane', 'Park'],
    'age': [25, 30, 35],
    '도시': ['서울', '부산', '대구'],
    'salary': [50000, 60000, 55000]
})

# to_json(): DataFrame을 JSON 파일로 저장
sample_data.to_json('sample_data.json',
                    orient='records',      # orient: JSON 구조 방식 지정
                    # 'records': [{}, {}, {}] 형태 (레코드 배열)
                    # 'columns': {컬럼명: {인덱스: 값}} 형태
                    # 'index': {인덱스: {컬럼명: 값}} 형태
                    indent=2)             # indent=2: 들여쓰기 2칸 (가독성 향상)
print('JSON 파일 저장')
print()

# ─────────────────────────────────────────────────────────────
# 8. JSON 파일 읽기
# ─────────────────────────────────────────────────────────────

# read_json(): JSON 파일을 읽어서 DataFrame으로 변환
df_json = pd.read_json('sample_data.json')
print('=== JSON 파일 읽기 ===')
print(df_json)
print()

# ═══════════════════════════════════════════════════════════════
# DataFrame 인덱싱과 슬라이싱
# ═══════════════════════════════════════════════════════════════
# DataFrame에서 원하는 데이터를 선택하고 추출하는 다양한 방법들

# 샘플 데이터 생성
data = {
    "이름": ["홍길동", "이순신", "김유신", "강감찬", "장보고", "이방원"],
    "나이": [23, 35, 31, 40, 28, 34],
    "직업": ["학생", "군인", "장군", "장군", "상인", "왕자"]
}
df = pd.DataFrame(data)

# ─────────────────────────────────────────────────────────────
# 9. 인덱싱 (Indexing) - 특정 열(컬럼) 선택
# ─────────────────────────────────────────────────────────────

print('=== 인덱싱 ===')

# 단일 열 선택: Series 형태로 반환
# Series: 1차원 배열 (하나의 열)
print(df["이름"])      # "이름" 열만 선택
print()

# 여러 열 선택: DataFrame 형태로 반환 (2차원 테이블 유지)
# 대괄호를 이중으로 사용 [[]] 해야 함
print(df[["이름", "나이", "직업"]])
print()

# ─────────────────────────────────────────────────────────────
# 10. 슬라이싱 (Slicing) - 특정 범위의 행 선택
# ─────────────────────────────────────────────────────────────

# 리스트 슬라이싱과 유사: [시작:끝] (끝 인덱스는 포함되지 않음)
print(df[1:3])         # 1번 행부터 2번 행까지 (0부터 시작하므로 2번째, 3번째 행)
print()

print(df[-2:])         # 뒤에서 2개 행 선택 (마지막 2개 행)
print()

# 주의: DataFrame의 기본 슬라이싱은 행(Row) 기준으로 동작
# 열(Column)을 슬라이싱하려면 명시적으로 지정해야 함
print(df[-2:]["이름"])  # 마지막 2개 행에서 "이름" 열만 선택
print()

# ─────────────────────────────────────────────────────────────
# 11. iloc - 정수 위치(integer location) 기반 인덱싱
# ─────────────────────────────────────────────────────────────
# iloc는 행과 열의 위치(0, 1, 2, ...)를 사용하여 데이터 선택
# 형식: df.iloc[행 인덱스, 열 인덱스]

print('=== iloc ===')
print(df)

# 단일 행 선택
print(df.iloc[0])      # 0번 행 전체를 Series로 반환
# 결과: 이름  홍길동, 나이  23, 직업  학생

# 모든 행의 특정 열 선택
print(df.iloc[:, 1])   # 모든 행(:)의 1번 열(나이) 선택
# :는 "전체"를 의미
print()

# 특정 행과 특정 열 선택
print(df.iloc[[0, 2, 4], [0, 2]])  # 0, 2, 4번 행과 0, 2번 열 선택
# 대괄호 [[]]로 여러 인덱스 지정
print()

# iloc 추가 예시:
# df.iloc[0:3, 0:2]     # 0~2번 행, 0~1번 열
# df.iloc[:, -1]        # 모든 행의 마지막 열
# df.iloc[-3:, :]       # 마지막 3개 행의 모든 열

# ─────────────────────────────────────────────────────────────
# 12. loc - 라벨(label) 기반 인덱싱
# ─────────────────────────────────────────────────────────────
# loc는 행/열의 이름(라벨)을 사용하여 데이터 선택
# 형식: df.loc[행 라벨, 열 라벨]

print('=== loc ===')

# 단일 행 선택 (인덱스 번호로)
print(df.loc[0])       # 인덱스 0인 행 전체 선택
# iloc[0]과 결과는 같지만 의미가 다름
# iloc는 "위치", loc는 "라벨"

# 모든 행의 특정 열 선택 (열 이름 사용)
print(df.loc[:, "나이"])  # 모든 행의 "나이" 열 선택
# iloc와 달리 열 이름(문자열) 사용 가능

# 여러 열 선택
print(df.loc[:, ["이름", "나이"]])  # 모든 행의 "이름"과 "나이" 열

# 특정 행 범위와 특정 열 선택
print(df.loc[1:3, ["이름", "나이"]])  # 1~3번 행의 "이름", "나이" 열
# 주의: loc는 끝 인덱스 포함! (iloc와 차이점)
# iloc[1:3]은 1, 2번 행만 포함
# loc[1:3]은 1, 2, 3번 행 모두 포함

# loc 추가 예시:
# df.loc[df['나이'] > 30, '이름']     # 나이가 30 초과인 사람의 이름
# df.loc[0:2, '이름':'직업']          # 0~2번 행, 이름부터 직업까지 모든 열

'''
═══════════════════════════════════════════════════════════════
iloc vs loc 차이점 정리
═══════════════════════════════════════════════════════════════

┌─────────────┬──────────────────┬──────────────────┐
│             │ iloc             │ loc              │
├─────────────┼──────────────────┼──────────────────┤
│ 인덱싱 방식  │ 정수 위치 (0, 1..)│ 라벨/이름        │
│ 끝 범위     │ 포함 안 됨        │ 포함됨           │
│ 열 선택     │ 정수만 가능       │ 이름 사용 가능    │
│ 조건 필터   │ 불가능           │ 가능             │
└─────────────┴──────────────────┴──────────────────┘

예시:
df.iloc[1:3, 0:2]  → 1, 2번 행 / 0, 1번 열
df.loc[1:3, '이름':'나이']  → 1, 2, 3번 행 / 이름부터 나이까지 모든 열

권장 사용법:
- iloc: 위치 기반 슬라이싱, 순차적 접근
- loc: 조건부 필터링, 명시적 열 이름 사용
'''

print()
print()
