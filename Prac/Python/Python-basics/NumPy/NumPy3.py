import numpy as np
print('10. NumPy 배열 인덱싱과 슬라이싱 완전 가이드')
print(
'''
    1) 팬시 인덱싱
    - 팬시 인덱싱 : 정수 배열을 사용하여 원하는 위치의 요소들을 선택하는 방법
    - 일반 인덱싱과 달리 여러 요소를 선택할 수 있으며 순서 변경과 중복도 가능
'''
)
print('1) 팬시 인덱싱')
arr = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90])
print('원본 배열 arr:\n', arr)
indices = [1, 3, 1, 7, 4, 7]
print('인덱스 [1, 3, 1, 7, 4, 7] 선택:\n', arr[indices])
'''
1) 팬시 인덱싱
원본 배열 arr:
[10 20 30 40 50 60 70 80 90]
인덱스 [1, 3, 1, 7, 4, 7] 선택:
[20 40 20 80 50 80]
'''
print()



print(
'''
    2) 양수 인덱싱
    - 배열의 앞에서 부터 0, 1, 2... 순서로 접근
    - 인덱스는 0부터 시작하므로 첫번째 요소는 arr[0]
'''
)
print('2) 양수 인덱싱')
print('첫번째 요소 (인덱스 0):', arr[0])  # 10
print('세번째 요소 (인덱스 2):', arr[2])  # 30
print('아홉번째 요소 (인덱스 8):', arr[8])  # 90
# print('열번째 요소 (인덱스 9):', arr[9])  # IndexError: 배열 크기를 벗어남

# 인덱싱을 통한 값 수정
# 특정 인덱스의 값을 직접 변경할 수 있음
arr[0] = 100
print('수정 후 배열 arr:\n', arr)  # 첫 번째 요소가 100으로 변경됨
'''
2) 양수 인덱싱
첫번째 요소 (인덱스 0): 10
세번째 요소 (인덱스 2): 30
아홉번째 요소 (인덱스 8): 90
수정 후 배열 arr:
[100  20  30  40  50  60  70  80  90]
'''
print()



print(
'''
    3) 음수 인덱싱
    - 배열의 뒤에서부터 -1, -2, -3, ... 순서로 접근
    - -1은 마지막 요소, -2는 마지막에서 두 번째 요소를 의미
'''
)
print('3) 음수 인덱싱')
print('마지막 요소 (인덱스 -1):', arr[-1])  # 90
print('마지막에서 두번째 요소 (인덱스 -2):', arr[-2])  # 80
print('마지막에서 여덟번째 요소 (인덱스 -8):', arr[-8])  # 20

# 음수 인덱스로도 값 수정 가능
arr[-3] = 400  # 뒤에서 세 번째 요소를 400으로 변경
print('수정 후 배열 arr:\n', arr)
'''
3) 음수 인덱싱
마지막 요소 (인덱스 -1): 90
마지막에서 두번째 요소 (인덱스 -2): 80
마지막에서 여덟번째 요소 (인덱스 -8): 20
수정 후 배열 arr:
[100  20  30  40  50  60 400  80  90]
'''
print()



print(
'''
    4) 배열의 슬라이싱
    슬라이싱 : 배열의 일부분을 연속적으로 추출하는 방법
    형식
    - arr[start, end, step]
    - start : 시작 인덱스 (포함)
    - end : 종료 인덱스 (제외)
    - step : 간격 (기본값 1)
'''
)
print('4) 배열의 슬라이싱')
arr = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90])
print('원본 배열 arr:\n', arr)

# 기본 슬라이싱 예제
print('인덱스 2부터 5까지 (5 제외):', arr[2:5])  # [30, 40, 50]
print('인덱스 처음부터 4까지 (4 제외):', arr[:4])  # [10, 20, 30, 40]
print('인덱스 3부터 마지막까지:', arr[3:])  # [40, 50, 60, 70, 80, 90]

# step을 사용한 슬라이싱
print('짝수 인덱스만 (0, 2, 4, ...):', arr[::2])  # [10, 30, 50, 70, 90]
print('홀수 인덱스만 (1, 3, 5, ...):', arr[1::2])  # [20, 40, 60, 80]
'''
4) 배열의 슬라이싱
원본 배열 arr:
[10 20 30 40 50 60 70 80 90]
인덱스 2부터 5까지 (5 제외): [30 40 50]
인덱스 처음부터 4까지 (4 제외): [10 20 30 40]
인덱스 3부터 마지막까지: [40 50 60 70 80 90]
짝수 인덱스만 (0, 2, 4, ...): [10 30 50 70 90]
홀수 인덱스만 (1, 3, 5, ...): [20 40 60 80]
'''
print()



print(
'''
    5) 슬라이싱으로 값 수정
    - 슬라이싱으로 선택한 범위의 값들 한번에 수정 가능
'''
)
print('5) 슬라이싱으로 값 수정')
# 단일 값으로 수정 - 선택한 모든 요소가 같은 값으로 변경됨
arr[2:5] = 100
print('인덱스 2~4를 100으로 수정:\n', arr)

# 배열로 수정 - 선택한 요소들을 각각 다른 값으로 변경
# 주의: 슬라이스 범위와 할당하는 배열의 길이가 같아야 함
arr[2:5] = [10, 20, 30]
print('인덱스 2~4를 [10, 20, 30]으로 수정:\n', arr)
# arr[2:5] = [10, 20]  # ValueError: 길이가 맞지 않음 (3개 위치에 2개 값)
'''
5) 슬라이싱으로 값 수정
인덱스 2~4를 100으로 수정:
[ 10  20 100 100 100  60  70  80  90]
인덱스 2~4를 [10, 20, 30]으로 수정:
[10 20 10 20 30 60 70 80 90]
'''
print()



print(
'''
    6) 뷰(view)와 복사(copy)
    
    중요개념 : NumPy의 슬라이싱은 뷰(view)를 반환
    뷰는 원본 데이터를 참조하므로 뷰를 수정하면 원본도 변경됨
'''
)
print('6) 뷰(view)와 복사(copy)')
original = np.array([1, 2, 3, 4, 5])
view = original[1:4]  # 뷰 생성 (원본 데이터를 참조)
print('original:\n', original)  # [1, 2, 3, 4, 5]
print('view:\n', view)  # [2, 3, 4]

# 뷰를 수정하면 원본도 변경됨
view[0] = 10
print('view[0]을 10으로 수정 후:')
print('original:\n', original)  # [1, 10, 3, 4, 5] - 원본도 변경됨!
print('view:\n', view)  # [10, 3, 4]

# 뷰의 여러 요소를 한 번에 수정
view[1:] = 20
print('view[1:]을 20으로 수정 후:')
print('original:\n', original)  # [1, 10, 20, 20, 5]
print('view:\n', view)  # [10, 20, 20]
'''
6) 뷰(view)와 복사(copy)
original:
[1 2 3 4 5]
view:
[2 3 4]
view[0]을 10으로 수정 후:
original:
[ 1 10  3  4  5]
view:
[10  3  4]
view[1:]을 20으로 수정 후:
original:
[ 1 10 20 20  5]
view:
[10 20 20]
'''
print()



print(
'''
    7) 독립적인 복사본 생성
    - 원본과 독립적인 배열이 필요한 경우 arr.copy() 메서드 사용
    - 복사본을 수정해도 원본은 영향을 받지 않음
'''
)
print('7) 독립적인 복사본 생성')
original = np.array([1, 2, 3, 4, 5])
copy = original[1:4].copy()  # 독립적인 복사본 생성

copy[0] = 100
print('copy[0]을 100으로 수정 후:')
print('original:\n', original)  # [1, 2, 3, 4, 5] - 원본은 변경되지 않음
print('copy:\n', copy)  # [100, 3, 4] - 복사본만 변경됨
'''
7) 독립적인 복사본 생성
copy[0]을 100으로 수정 후:
original:
[1 2 3 4 5]
copy:
[100   3   4]
'''
print()



print(
'''
    8) 2차원 배열 인덱싱 
    - 2차원 배열은 [행, 열] 형식으로 접근
    - matrix[i, j]는 i번째 행 j번째 열의 요소를 의미
'''
)
print('8) 2차원 배열 인덱싱')
matrix = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
])

print('2차원 배열:\n', matrix)

# 특정 요소 접근
print('(0, 0) 요소:', matrix[0, 0])  # 1 - 첫 번째 행, 첫 번째 열
print('(2, 2) 요소:', matrix[2, 2])  # 9 - 세 번째 행, 세 번째 열
print('(1, 2) 요소:', matrix[1, 2])  # 6 - 두 번째 행, 세 번째 열

# 두 가지 표기법: matrix[i, j]와 matrix[i][j]는 같은 결과
print('(1, 2) 요소 (대괄호 2번):', matrix[1][2])  # 6

# print('(3, 0) 요소:', matrix[3, 0])  # IndexError: 행 인덱스 범위 초과

# 음수 인덱스도 2차원 배열에서 사용 가능
print('(-1, -2) 요소:', matrix[-1, -2])  # 8 - 마지막 행, 뒤에서 두 번째 열
print('(-1, -2) 요소 (대괄호 2번):', matrix[-1][-2])  # 8
'''
8) 2차원 배열 인덱싱
2차원 배열:
[[1 2 3]
[4 5 6]
[7 8 9]]
(0, 0) 요소: 1
(2, 2) 요소: 9
(1, 2) 요소: 6
(1, 2) 요소 (대괄호 2번): 6
(-1, -2) 요소: 8
(-1, -2) 요소 (대괄호 2번): 8
'''
print()



print(
'''
    9) 2차원 배열 행 선택
    - 단일 인덱스를 사용하면 행 전체를 선택
'''
)
print('9) 2차원 배열 행 선택')
print('첫 번째 행:', matrix[0])  # [1, 2, 3]
print('두 번째 행:', matrix[1])  # [4, 5, 6]

# 슬라이싱으로 여러 행 선택
print('처음 두 행:\n', matrix[:2])  # [[1, 2, 3], [4, 5, 6]]
'''
9) 2차원 배열 행 선택
첫 번째 행: [1 2 3]
두 번째 행: [4 5 6]
처음 두 행:
[[1 2 3]
[4 5 6]]
'''
print()



print(
'''
    10) 2차원 배열 슬라이싱 - 부분 행렬 추출
    - 2차원 슬라이싱 : matrix[행_범위, 열_범위]
    - 행과 열을 각각 슬라이싱하여 부분 행렬 추출
'''
)
matrix = np.array([
    [1,  2,  3,  4,  5],
    [6,  7,  8,  9, 10],
    [11, 12, 13, 14, 15],
    [16, 17, 18, 19, 20]
])
print("10) 2차원 배열 슬라이싱 - 부분 행렬 추출")
print('원본 행렬:\n', matrix)

# 처음 두 행, 두 번째 열부터 끝까지
print('matrix[:2, 1:]:\n', matrix[:2, 1:])
# 결과: [[ 2  3  4  5]
#       [ 7  8  9 10]]

# 두 번째~세 번째 행, 두 번째~네 번째 열
print('matrix[1:3, 1:4]:\n', matrix[1:3, 1:4])
# 결과: [[ 7  8  9]
#       [12 13 14]]

# 짝수 행과 짝수 열만 선택 (step=2)
print('matrix[::2, ::2]:\n', matrix[::2, ::2])
# 결과: [[ 1  3  5]
#       [11 13 15]]
print()



print(
'''
    11) 2차원 배열 - 팬시 인덱싱으로 특정 행들 선택
'''
)
matrix = np.array([
    [1,  2,  3,  4,  5],
    [6,  7,  8,  9, 10],
    [11, 12, 13, 14, 15],
    [16, 17, 18, 19, 20]
])

# 정수 배열을 사용하여 원하는 행들만 선택
row_indices = [0, 2, 3]
print("11) 팬시 인덱싱으로 특정 행들 선택")
print('[0, 2, 3]번 행 선택:\n', matrix[row_indices])
'''
11) 팬시 인덱싱으로 특정 행들 선택
[0, 2, 3]번 행 선택:
[[ 1  2  3  4  5]
[11 12 13 14 15]
[16 17 18 19 20]]
'''
print()



print(
'''
    12) 2차원 배열 - 팬시 인덱싱으로 특정 요소들 선택
'''
)
matrix = np.array([
    [1,  2,  3,  4,  5],
    [6,  7,  8,  9, 10],
    [11, 12, 13, 14, 15],
    [16, 17, 18, 19, 20]
])

# 행 인덱스 배열과 열 인덱스 배열을 동시에 사용
# (row_indices[i], col_indices[i]) 위치의 요소들을 선택

row_indices = [0, 2, 2]
col_indices = [3, 2, 3]
print("12) 팬시 인덱싱으로 특정 요소들 선택")
print('특정 요소들 선택 (0,3), (2,2), (2,3):\n',
      matrix[row_indices, col_indices])
# 결과: [ 4 13 14] - 각각 (0,3), (2,2), (2,3) 위치의 요소

'''
12) 팬시 인덱싱으로 특정 요소들 선택
특정 요소들 선택 (0,3), (2,2), (2,3):
[ 4 13 14]
'''
print()



print(
'''
    13) 불린 인덱싱 - 1차원 배열
    - 조건식을 사용하여 조건을 만족하는 요소들만 선택
    - 조건식은 True/False 배열을 반환하고, True 위치의 요소들만 선택됨
'''
)
arr = np.array([1, 5, 4, 7, 2, 3])
print("13) 불린 인덱싱 - 1차원 배열")
print('원본 배열:', arr)

# 단일 조건
print('4 이상인 요소:', arr[arr >= 4])  # [5, 4, 7]

# 여러 조건 결합
# | (or): 둘 중 하나라도 True이면 선택
print('2 미만 또는 4 이상:', arr[(arr >= 4) | (arr < 2)])  # [1, 5, 4, 7]

# & (and): 둘 다 True여야 선택
print('2 이상 4 이하:', arr[(2 <= arr) & (arr <= 4)])  # [4, 2, 3]

'''
13) 불린 인덱싱 - 1차원 배열
원본 배열: [1 5 4 7 2 3]
4 이상인 요소: [5 4 7]
2 미만 또는 4 이상: [1 5 4 7]
2 이상 4 이하: [4 2 3]
'''
print()



print(
'''
    14) 불린 인덱싱 - 2차원 배열
    - 2차원 배열에서도 조건을 만족하는 요소들을 선택 가능
'''
)
matrix = np.array([
    [1,  2,  3,  4,  5],
    [6,  7,  8,  9, 10],
    [11, 12, 13, 14, 15],
    [16, 17, 18, 19, 20]
])
print("14) 불린 인덱싱 - 2차원 배열")
print('원본 행렬:\n', matrix)

# 9보다 큰 모든 요소 선택 (1차원 배열로 반환됨)
print('9보다 큰 요소들:', matrix[matrix > 9])
# 결과: [10 11 12 13 14 15 16 17 18 19 20]

# 특정 열의 조건으로 행 전체 선택
# 첫 번째 열(matrix[:, 0])의 값이 4 이상인 행들만 선택
print('첫 번째 열이 4 이상인 행들:\n', matrix[matrix[:, 0] >= 4])
'''
14) 불린 인덱싱 - 2차원 배열
원본 행렬:
 [[ 1  2  3  4  5]
 [ 6  7  8  9 10]
 [11 12 13 14 15]
 [16 17 18 19 20]]
9보다 큰 요소들: [10 11 12 13 14 15 16 17 18 19 20]
첫 번째 열이 4 이상인 행들:
 [[ 6  7  8  9 10]
 [11 12 13 14 15]
 [16 17 18 19 20]]
'''
print()



print(
'''
    15) 불린 인덱싱으로 값 수정
    - 조건을 만족하는 모든 요소를 한번에 수정 가능
'''
)
matrix = np.array([
    [1,  2,  3,  4,  5],
    [6,  7,  8,  9, 10],
    [11, 12, 13, 14, 15],
    [16, 17, 18, 19, 20]
])
print("15) 불린 인덱싱으로 값 수정")
matrix[matrix > 9] = 10  # 9보다 큰 모든 요소를 10으로 변경
print('9보다 큰 요소를 10으로 수정한 행렬:\n', matrix)
'''
15) 불린 인덱싱으로 값 수정
9보다 큰 요소를 10으로 수정한 행렬:
 [[ 1  2  3  4  5]
 [ 6  7  8  9 10]
 [10 10 10 10 10]
 [10 10 10 10 10]]
'''



print(
'''
    16) NumPy 배열 인덱싱과 슬라이싱 핵심 개념 요약
    1. 팬시 인덱싱 : 정수 리스트로 원하는 요소들을 선택 (중복, 순서 변경 가능)
    2. 양수/음수 인덱싱: 앞에서부터(0, 1, ...) 또는 뒤에서부터(-1, -2, ...)
    3. 슬라이싱: [start:stop:step] 형식으로 연속된 범위 선택
    4. 뷰 vs 복사: 슬라이싱은 뷰를 반환 (원본 참조), .copy()로 독립적인 복사본 생성
    5. 2차원 인덱싱: [행, 열] 형식으로 접근
    6. 불린 인덱싱: 조건식으로 조건을 만족하는 요소만 선택 및 수정
'''
)
