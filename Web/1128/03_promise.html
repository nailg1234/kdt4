<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Promise</title>
  </head>
  <body>
    <script>
      // ============================================
      // Promise (프로미스)
      // ============================================
      // Promise는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체
      // 콜백 지옥을 해결하기 위해 ES6에서 도입되었습니다

      // ============================================
      // 1. 콜백 지옥의 문제
      // ============================================
      // 콜백 지옥 예시 (읽기 어렵고 유지보수가 힘듦)
      // getData(function (a) {
      //   getMoreData(a, function (b) {
      //     getMoreData(b, function (c) {
      //       getMoreData(c, function (d) {
      //         // 끝없이 중첩...
      //       });
      //     });
      //   });
      // });

      // Promise로 해결 (깔끔한 체이닝)
      // getData()
      //   .then((a) => getMoreData(a))
      //   .then((b) => getMoreData(b))
      //   .then((c) => getMoreData(c))
      //   .then((d) => console.log(d));

      // ============================================
      // 2. Promise 생성 방법
      // ============================================
      // new Promise((resolve, reject) => { ... })
      // - resolve: 성공 시 호출할 함수
      // - reject: 실패 시 호출할 함수

      // 기본 구조:
      // const promise = new Promise((resolve, reject) => {
      //   // 비동기 작업 수행
      //
      //   if (성공) {
      //     resolve(결과); // 성공한 결과 전달
      //   } else {
      //     reject(에러); // 에러 전달
      //   }
      // });

      // 📌 성공 예제
      const successPromise = new Promise((resolve, reject) => {
        // 1초 후 성공 결과 반환
        setTimeout(() => {
          resolve("데이터를 성공적으로 가져왔습니다.");
        }, 1000);
      });

      // .then()으로 성공 결과 처리
      successPromise.then((result) => {
        console.log(result); // "데이터를 성공적으로 가져왔습니다."
      });

      // 📌 실패 예제
      const failPromise = new Promise((resolve, reject) => {
        // 1초 후 실패 반환
        setTimeout(() => {
          reject("데이터 로드 실패!!!");
        }, 1000);
      });

      // .then()만 사용하면 에러 처리 안 됨 (콘솔에 에러 표시)
      failPromise.then((result) => {
        console.log(result); // 실행되지 않음
      });

      // ============================================
      // 3. Promise 메서드
      // ============================================

      // 📌 .then() - 성공 처리
      // promise.then(successCallback, failureCallback)
      // 일반적으로는 성공만 처리:
      // promise.then((result) => {
      //   console.log(result);
      // });

      // 📌 .catch() - 실패 처리
      // promise.catch((error) => {
      //   console.error(error);
      // });

      // 📌 .finally() - 성공/실패 상관없이 무조건 실행
      // 주로 로딩 상태 해제 등에 사용

      const fetchData = new Promise((resolve, reject) => {
        setTimeout(() => {
          // 네트워크 에러 시뮬레이션
          reject(new Error("네트워크 에러 발생!!!"));
        }, 1000);
      });

      fetchData
        .then((data) => {
          // 성공 시 실행 (이 예제에서는 실행되지 않음)
          console.log("성공:", data);
        })
        .catch((error) => {
          // 실패 시 실행
          console.error("에러 발생:", error.message);
        })
        .finally(() => {
          // 성공/실패 상관없이 무조건 실행
          console.log("작업 완료 (로딩 해제 등)");
        });

      // ============================================
      // 4. Promise 체이닝 (Chaining)
      // ============================================
      // .then()을 연결하여 순차적으로 비동기 작업 수행
      // 각 .then()은 이전 .then()의 반환값을 받습니다

      Promise.resolve(10) // 10으로 시작하는 Promise 생성
        .then((num) => {
          console.log(num); // 10 출력
          return num * 2; // 20을 다음 .then()에 전달
        })
        .then((num) => {
          console.log(num); // 20 출력
          return num + 5; // 25를 다음 .then()에 전달
        })
        .then((num) => {
          console.log(num); // 25 출력
        });

      // 실행 순서:
      // 1. Promise.resolve(10) -> 10
      // 2. 첫 번째 .then() -> 10 * 2 = 20
      // 3. 두 번째 .then() -> 20 + 5 = 25
      // 4. 세 번째 .then() -> 25 출력

      // ============================================
      // 5. Promise 정적 메서드
      // ============================================

      // 📌 Promise.all() - 모든 Promise가 성공해야 함
      // 하나라도 실패하면 전체 실패
      // 모두 성공하면 결과를 배열로 반환

      // 사용법:
      // Promise.all([promise1, promise2, promise3])
      //   .then((results) => {
      //     console.log(results); // [결과1, 결과2, 결과3]
      //   })
      //   .catch((error) => {
      //     console.error("하나라도 실패하면 실패", error);
      //   });

      // 실제 예제
      const fetchUser = Promise.resolve({ id: 1, name: "홍길동" });
      const fetchPost = Promise.resolve({ title: "제목" });
      const fetchComments = Promise.resolve({ text: "댓글" });

      Promise.all([fetchUser, fetchPost, fetchComments])
        .then((results) => {
          console.log("모든 데이터:", results);
          // [{ id: 1, name: "홍길동" }, { title: "제목" }, { text: "댓글" }]
        })
        .catch((error) => {
          console.error("하나라도 실패하면 실패", error);
        });

      // 사용 사례: 여러 API를 동시에 호출하고 모두 성공해야 할 때

      // 📌 Promise.race() - 가장 빠른 것
      // 가장 먼저 완료되는 Promise의 결과 반환 (성공이든 실패든)
      // Promise.race([promise1, promise2, promise3])
      //   .then((result) => {
      //     console.log("가장 빠른 결과:", result);
      //   });
      // 사용 사례: 타임아웃 구현, 가장 빠른 서버 응답 사용

      // 📌 Promise.allSettled() - 모두 완료 대기
      // 성공/실패 여부와 관계없이 모든 Promise가 완료되면 결과 반환
      // 각 Promise의 상태(status)와 값(value) 또는 이유(reason) 반환
      // Promise.allSettled([promise1, promise2, promise3])
      //   .then((results) => {
      //     results.forEach((result) => {
      //       if (result.status === "fulfilled") {
      //         console.log("성공:", result.value);
      //       } else {
      //         console.log("실패:", result.reason);
      //       }
      //     });
      //   });
      // 사용 사례: 여러 작업의 성공/실패 여부를 모두 확인할 때

      // ============================================
      // 6. 실전 예제: 랜덤 성공/실패 Promise
      // ============================================

      function randomPromise() {
        return new Promise((resolve, reject) => {
          // 50% 확률로 성공/실패
          if (Math.random() > 0.5) {
            resolve("성공!!!");
          } else {
            reject(new Error("실패!!!"));
          }
        });
      }

      randomPromise()
        .then((message) => {
          console.log("✅", message); // 성공 시
        })
        .catch((error) => {
          console.log("❌", error.message); // 실패 시
        });

      // 💡 Promise의 3가지 상태:
      // 1. Pending (대기): 초기 상태, 아직 완료되지 않음
      // 2. Fulfilled (이행): 작업이 성공적으로 완료됨
      // 3. Rejected (거부): 작업이 실패함

      // 💡 Promise의 장점:
      // 1. 콜백 지옥 해결
      // 2. 에러 처리 간편 (.catch()로 통합 처리)
      // 3. 코드 가독성 향상
      // 4. 여러 비동기 작업 조합 가능 (Promise.all 등)
    </script>
  </body>
</html>
